from __future__ import annotations
import httpx
from typing import List, Dict
from openpyxl import load_workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Font

# file & worksheet settings
SPREADSHEET_PATH     = 'the/spreadsheet/path/myspreadsheet.xlsx'
TARGET_WORKSHEET     = 'sheet1'
WER_SHEET_NAME       = 'WER'
WER_ENDPOINT         = 'http://api_for_wer:2517/wer'

# column names
ID_COL               = "ID"
TRANSCRIPTION_COL    = "transcribed_text"
GROUND_TRUTH_COL     = "ground_truth"
WER_COL              = "WER"

# output column widths
ID_WIDTH             = 30
TRANSCRIPTION_WIDTH  = 50
GROUND_TRUTH_WIDTH   = 50
WER_WIDTH            = 10

def aggregate_row_text(texts: List[str]) -> str:
    #Existing helper; concatenate a list of text fragments into one block.
    return " ".join(texts)

def load_data(ws) -> List[Dict[str, str]]:
    #Read all rows from a worksheet into a list of dicts keyed by header.
    rows = list(ws.iter_rows(values_only=True))
    headers = [h for h in rows[0]]
    return [
        {headers[i]: row[i] for i in range(len(headers))}
        for row in rows[1:]
    ]

def group_by_id(data: List[Dict[str, str]]) -> Dict[str, List[Dict[str, str]]]:
    #Group row‐dicts by the value in the ID column.#
    groups: Dict[str, List[Dict[str, str]]] = {}
    for row in data:
        key = str(row.get(ID_COL, "")).strip()
        groups.setdefault(key, []).append(row)
    return groups

def aggregate_fields(
    groups: Dict[str, List[Dict[str, str]]],
    field: str,
) -> Dict[str, str]:
    #Use aggregate_row_text to combine all values of `field` per ID.
    return {
        key: aggregate_row_text([r.get(field, "") for r in rows])
        for key, rows in groups.items()
    }

def calculate_wer(
    ground_truth: str,
    transcript: str,
    wer_endpoint: str
) -> str:
    #Call the WER service and return a 2‐decimal string or error.
    resp = httpx.post(
        wer_endpoint,
        json={"groundTruth": ground_truth, "transcript": transcript},
        timeout=5.0,
    )
    text = resp.text.strip()
    try:
        return f"{float(text):.2f}"
    except ValueError:
        return "WER API Error"

def create_wer_sheet(
    spreadsheet_path: str,
    target_worksheet: str,
    wer_sheet_name: str,
    wer_endpoint: str,
) -> None:
    #Generate (or regenerate) a WER sheet in the existing spreadsheet.
    wb = load_workbook(spreadsheet_path)
    src = wb[target_worksheet]

    # 1. load and group
    data        = load_data(src)
    groups      = group_by_id(data)
    transcripts = aggregate_fields(groups, TRANSCRIPTION_COL)
    ground_ts   = aggregate_fields(groups, GROUND_TRUTH_COL)

    # 2. recreate WER sheet
    if wer_sheet_name in wb.sheetnames:
        del wb[wer_sheet_name]
    ws = wb.create_sheet(wer_sheet_name)

    # 3. write header
    headers = [ID_COL, TRANSCRIPTION_COL, GROUND_TRUTH_COL, WER_COL]
    ws.append(headers)

    # 4. write rows
    for id_val in sorted(groups):
        wer_value = calculate_wer(ground_ts[id_val], transcripts[id_val], wer_endpoint)
        ws.append([id_val, transcripts[id_val], ground_ts[id_val], wer_value])

    # 5. style
    header_font = Font(name="Aptos", size=9, bold=True)
    data_font   = Font(name="Aptos", size=9)
    for cell in ws[1]:
        cell.font = header_font
    for row in ws.iter_rows(min_row=2, max_col=len(headers)):
        for cell in row:
            cell.font = data_font

    ws.freeze_panes     = "A2"
    ws.auto_filter.ref  = f"A1:{get_column_letter(len(headers))}{ws.max_row}"

    # 6. set column widths
    widths = [ID_WIDTH, TRANSCRIPTION_WIDTH, GROUND_TRUTH_WIDTH, WER_WIDTH]
    for idx, w in enumerate(widths, start=1):
        ws.column_dimensions[get_column_letter(idx)].width = w

    # 7. save
    wb.save(spreadsheet_path)

if __name__ == "__main__":
    create_wer_sheet(
        SPREADSHEET_PATH,
        TARGET_WORKSHEET,
        WER_SHEET_NAME,
        WER_ENDPOINT,
    )