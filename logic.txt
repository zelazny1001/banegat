# micro_metrics_calculation

from __future__ import annotations
from typing import List, Tuple
import pandas as pd
from openpyxl.utils import get_column_letter
from openpyxl.styles import Alignment, Font

# globals
SPREADSHEET_PATH = "accuracy-test.xlsx"
GROUND_TRUTH_WORKSHEET = "GroundTruth"
PREDICTORS = ["v1", "v2", "transformer"]
INTENTS = ["INTENT_1", "INTENT_2", "INTENT_3"]
MICRO_RESULTS_WORKSHEET = "micro"

def get_intent_column(df: pd.DataFrame) -> pd.Series:
    for col in df.columns:
        if col.strip().lower() == "intent":
            return df[col]
    raise ValueError("No 'Intent' column found in the DataFrame.")

def load_intent_series(filepath: str, worksheet_name: str) -> pd.Series:
    df = pd.read_excel(filepath, sheet_name=worksheet_name, engine="openpyxl")
    return get_intent_column(df)

def compute_one_vs_all(ground_truth: pd.Series, prediction: pd.Series, intent: str) -> Tuple[int, int, int]:
    TP = ((ground_truth == intent) & (prediction == intent)).sum()
    FP = ((ground_truth != intent) & (prediction == intent)).sum()
    FN = ((ground_truth == intent) & (prediction != intent)).sum()
    return TP, FP, FN

def compute_totals(ground_truth: pd.Series, prediction: pd.Series, intents: List[str]) -> Tuple[int, int, int]:
    total_TP = total_FP = total_FN = 0
    for intent in intents:
        TP, FP, FN = compute_one_vs_all(ground_truth, prediction, intent)
        total_TP += TP
        total_FP += FP
        total_FN += FN
    return total_TP, total_FP, total_FN

def compute_micro_metrics(TP: int, FP: int, FN: int) -> Tuple[float, float, float, float]:
    precision = TP / (TP + FP) if (TP + FP) > 0 else 0
    recall = TP / (TP + FN) if (TP + FN) > 0 else 0
    f1 = (2 * precision * recall) / (precision + recall) if (precision + recall) > 0 else 0
    f05 = (1.25 * precision * recall) / (0.25 * precision + recall) if (precision + recall) > 0 else 0
    return precision, recall, f1, f05

def prepare_micro_results(filepath: str, intents: List[str]) -> pd.DataFrame:
    truth_series = load_intent_series(filepath, GROUND_TRUTH_WORKSHEET)
    rows = []

    for predictor in PREDICTORS:
        pred_series = load_intent_series(filepath, predictor)
        if len(pred_series) != len(truth_series):
            raise ValueError(f"Row count mismatch between {GROUND_TRUTH_WORKSHEET} and {predictor}.")
        TP, FP, FN = compute_totals(truth_series, pred_series, intents)
        precision, recall, f1, f05 = compute_micro_metrics(TP, FP, FN)
        accuracy = TP / len(truth_series) if len(truth_series) > 0 else 0
        rows.append({
            "Predictor": predictor,
            "TP": TP,
            "FP": FP,
            "FN": FN,
            "Precision": precision,
            "Recall": recall,
            "F1": f1,
            "F0.5": f05,
            "Accuracy": accuracy
        })

    return pd.DataFrame(rows)

def write_micro_results(filepath: str, df: pd.DataFrame) -> None:
    with pd.ExcelWriter(filepath, engine="openpyxl", mode="a", if_sheet_exists="replace") as writer:
        df.to_excel(writer, sheet_name=MICRO_RESULTS_WORKSHEET, index=False)
        ws = writer.book[MICRO_RESULTS_WORKSHEET]
        for i, col in enumerate(df.columns, 1):
            ws.column_dimensions[get_column_letter(i)].width = 12
        for row_idx, row in enumerate(ws.iter_rows()):
            for col_idx, cell in enumerate(row):
                if row_idx == 0:
                    cell.font = Font(name="Aptos", size=9, bold=True)
                    cell.alignment = Alignment(horizontal="center", vertical="center")
                else:
                    cell.font = Font(name="Aptos", size=9)
                    cell.alignment = Alignment(horizontal="center", vertical="center")
                    if isinstance(cell.value, float):
                        cell.number_format = '0.00%'

def doMicroCalculations(filepath: str, intents: List[str]) -> None:
    df = prepare_micro_results(filepath, intents)
    write_micro_results(filepath, df)

def main() -> None:
    doMicroCalculations(SPREADSHEET_PATH, INTENTS)

if __name__ == "__main__":
    main()