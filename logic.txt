# svm_predictor.py

from __future__ import annotations
import pickle
from sklearn import svm
from sklearn.feature_extraction import DictVectorizer
from sklearn.preprocessing import LabelEncoder

PREDICTOR_ROOT_DIR = "/tmp/svm/predictor/"
MODEL_ROOT_DIR = "/tmp/svm/training"
MODEL_PATH = MODEL_ROOT_DIR + "svm.model"
SVM_TEST_DATA_PATH = PREDICTOR_ROOT_DIR + "test_data.txt"
SVM_PREDICTED_RESULTS_PATH = PREDICTOR_ROOT_DIR + "svm_predicted_results.txt"

TEST_DATA_HEADER = "utterance | features"
SVM_PREDICTED_DATA_HEADER = "utterance | intent"

def load_trained_model(path: str) -> tuple[svm.SVC, DictVectorizer, LabelEncoder]:
    with open(path, 'rb') as f:
        data = pickle.load(f)
    return data['model'], data['vectorizer'], data['label_encoder']

def load_test_data(path: str, header: str) -> list[tuple[str, str, dict]]:
    with open(path, encoding='utf-8') as f:
        lines = [line.strip() for line in f if line.strip()]
    assert lines[0] == header
    data = []
    for idx, line in enumerate(lines[1:], start=2):
        try:
            parts = [x.strip() for x in line.split('|')]
            if len(parts) != 2:
                print(f"Malformed row on line {idx}: {line}")
                continue
            feature_str = parts[1]
            if feature_str.startswith('[') and feature_str.endswith(']'):
                feature_str = feature_str[1:-1]
            items = [item.strip().strip("'") for item in feature_str.split(',') if item.strip()]
            feats = dict(pair.split('=') for pair in items if '=' in pair)
            data.append((parts[0], feats))
        except Exception as e:
            print(f"Error processing line {idx}: {line} â€“ {e}")
    return data

def get_svm_predictions(model, vectorizer, label_encoder, data: list[tuple[str, dict]]) -> list[tuple[str, str]]:
    feats_only = [feats for _, feats in data]
    X = vectorizer.transform(feats_only)
    y_pred = model.predict(X)
    predicted_labels = label_encoder.inverse_transform(y_pred)
    return [(utterance, label) for (utterance, _), label in zip(data, predicted_labels)]

def svm_write_predictions_to_file(results: list[tuple[str, str]], path: str, header: str):
    with open(path, 'w', encoding='utf-8') as f:
        f.write(f"{header}\n")
        for utterance, intent in results:
            f.write(f"{utterance} | {intent}\n")
    print(f"Predictions written to {path}")

def main():
    model_path = MODEL_PATH
    test_data_path = SVM_TEST_DATA_PATH
    predicted_output_path = SVM_PREDICTED_RESULTS_PATH
    test_data_header = TEST_DATA_HEADER
    predicted_data_header = SVM_PREDICTED_DATA_HEADER

    model, vectorizer, label_encoder = load_trained_model(model_path)
    print("Model loaded")

    data = load_test_data(test_data_path, test_data_header)
    print(f"Loaded {len(data)} test samples")

    results = get_svm_predictions(model, vectorizer, label_encoder, data)
    svm_write_predictions_to_file(results, predicted_output_path, predicted_data_header)

if __name__ == "__main__":
    main()