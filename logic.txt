# === constants.py ===

from __future__ import annotations

USE_HALLUCINATION_FLAGS: bool = False
CODE_IS_BEING_TESTED: bool = True

ROOT_DIR: str = "j:/projects/sheet-logic/asr-april-2025-data/"
SPREADSHEET_PREFIX: str = "ASR"
WORKSHEET_PREFIX: str = "ASR"
DO_MONTHLY_CONSOLIDATION: bool = True
CALL_LEVEL_GRANULARITY: bool = True

SESSION_ID_COL_NAME: str = "session_id"
RAW_TRANSCRIPT_COL_NAME: str = "raw_transcript"
GROUND_TRUTH_COL_NAME: str = "Ground Truth Transcript"
HALLUCINATION_COL_NAME: str = "Hallucination"

INPUT_DATA_WORKSHEET_NAME: str = "input-data"

METRICS_WORKSHEET_NAME: str = "metrics"
METADATA_COL_NAME: str = "metadata"
SECTION_COL_NAME: str = "section"
ENTIRE_COL_NAME: str = "entire"
GT_SECTION_TEXT_COL_NAME: str = "gt section"
MODEL_SECTION_TEXT_COL_NAME: str = "model text"
WER_COL_NAME: str = "WER"
HALLUCINATION_COUNT_COL_NAME: str = "Hallucination"
GT_TOKS_COL_NAME: str = "GT Toks"
HALLUCINATION_PERCENT_COL_NAME: str = "Hallucination %"

NUMBER_OF_SECTIONS: int = 5
WER_POST_ENDPOINT: str = "https://wer_host:3281/word_error_rate"

WEEKLY_SUMMARY_WORKSHEET_NAME: str = "weekly-summary"
AVERAGE_WER_COL_NAME: str = "AVG_WER"
SESSION_COUNT_COL_NAME: str = "num sessions"
SUMMARY_HALLUCINATION_COUNT_COL_NAME: str = "Hallucination Count"
HALLUCINATION_AVG_COL_NAME: str = "Hallucination Avg"

CALL_SUMMARY_WORKSHEET_NAME: str = "call-summary"
AVG_HALLUCINATION_PERCENT_COL_NAME: str = "Avg Hallucination %"

CALL_LEVEL_BKGND_COLOR: str = "00FFFF"
SAMPLE_LEVEL_BKGND_COLOR: str = "FFFFFF"
SOURCE_COL_WIDTHS = {"A": 69, "B": 35, "C": 35, "D": 12}
METRICS_HEADER_COL_WIDTHS = {"A": 27, "B": 65, "C": 9, "D": 63, "E": 63, "F": 8, "G": 12, "H": 10, "I": 15}
SUMMARY_COL_WIDTHS = {"A": 30, "B": 13, "C": 16, "D": 22}


# === file_io.py ===

from __future__ import annotations
import os
import re
from typing import Optional, Tuple
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font, Alignment
from openpyxl.utils import get_column_letter
from constants import (
    ROOT_DIR,
    WORKSHEET_PREFIX,
    SPREADSHEET_PREFIX,
    METRICS_WORKSHEET_NAME,
    METRICS_HEADER_COL_WIDTHS
)
from styling import style_copied_input_worksheet, style_metrics_header, format_metrics_cells
from input_processing import add_input_data_worksheet_with_metadata
from metrics_processing import add_metrics_sheet, write_metrics_header, compute_and_write_session_metrics
from weekly_summary import add_weekly_summary_sheet, write_weekly_summary
from overall_summary import add_overall_summary_sheet

def list_input_spreadsheets(root_dir: str) -> list[str]:
    return sorted(
        os.path.join(root_dir, name)
        for name in os.listdir(root_dir)
        if name.startswith(f"{SPREADSHEET_PREFIX}_")
        and name.lower().endswith(".xlsx")
        and not name.endswith("_metrics.xlsx")
        and not name.endswith("_monthly_metrics.xlsx")
    )

def get_results_spreadsheet_path(input_path: str) -> str:
    directory = os.path.dirname(input_path)
    base = os.path.basename(input_path).rsplit(".", 1)[0]
    return os.path.join(directory, f"{base}_metrics.xlsx")

def qualifies_for_processing(input_path: str) -> Tuple[bool, Optional[str]]:
    try:
        workbook = load_workbook(input_path, read_only=True, data_only=True, keep_links=False)
        try:
            worksheet_name = next((n for n in workbook.sheetnames if n.startswith(WORKSHEET_PREFIX)), None)
        finally:
            workbook.close()
        return (worksheet_name is not None, worksheet_name)
    except Exception:
        return (False, None)

from typing import Optional

def build_metrics_workbook_from_input(input_path: str) -> Optional[str]:
    is_valid_input, input_data_worksheet_name = qualifies_for_processing(input_path)
    if not is_valid_input or not input_data_worksheet_name:
        return None

    input_data_workbook = load_workbook(input_path, read_only=True, data_only=True, keep_links=False)
    try:
        worksheet_from_business = input_data_workbook[input_data_worksheet_name]

        output_path = get_results_spreadsheet_path(input_path)
        if os.path.exists(output_path):
            os.remove(output_path)

        output_workbook = Workbook()
        copied_input_worksheet = output_workbook.active
        copied_input_worksheet.title = input_data_worksheet_name

        for row_values in worksheet_from_business.iter_rows(values_only=True):
            copied_input_worksheet.append(row_values)

        style_copied_input_worksheet(copied_input_worksheet)

        metrics_worksheet = add_metrics_sheet(output_workbook)
        write_metrics_header(metrics_worksheet)

        metadata_value = os.path.basename(input_path).rsplit(".", 1)[0]
        compute_and_write_session_metrics(worksheet_from_business, metrics_worksheet, metadata_value)
        weekly_worksheet = add_weekly_summary_sheet(output_workbook)
        write_weekly_summary(metrics_worksheet, weekly_worksheet)
        add_overall_summary_sheet(output_workbook, metrics_worksheet)
        output_workbook.save(output_path)
        return output_path
    finally:
        input_data_workbook.close()


def get_monthly_output_filepath(root_dir: str, metrics_paths: list[str], prefix: str) -> tuple[str, str, str, str]:
    dates = []
    for metrics_path in metrics_paths:
        base = os.path.basename(metrics_path).rsplit(".", 1)[0]
        parts = base.split("_")
        rng, year = parts[1], parts[2]
        start, end = re.split(r"thru|-", rng, maxsplit=1)
        dates.append((start, end, year))
    earliest = min(d[0] for d in dates)
    latest = max(d[1] for d in dates)
    year = dates[0][2]
    filename = f"{prefix}_{earliest}thru{latest}_{year}_monthly_metrics.xlsx"
    return os.path.join(root_dir, filename), earliest, latest, year

def create_monthly_workbook(root_dir: str, metrics_paths: list[str], prefix: str) -> str:
    monthly_path, _, _, _ = get_monthly_output_filepath(root_dir, metrics_paths, prefix)
    if os.path.exists(monthly_path):
        os.remove(monthly_path)
    monthly_workbook = Workbook()
    del monthly_workbook[monthly_workbook.sheetnames[0]]
    add_input_data_worksheet_with_metadata(monthly_workbook, metrics_paths)
    monthly_metrics_worksheet = monthly_workbook.create_sheet(METRICS_WORKSHEET_NAME)
    first = True
    for metrics_path in metrics_paths:
        metrics_wb = load_workbook(metrics_path)
        metrics_ws = metrics_wb[METRICS_WORKSHEET_NAME]
        for i, row_values in enumerate(metrics_ws.iter_rows(values_only=True), start=1):
            if i == 1 and not first:
                continue
            monthly_metrics_worksheet.append(row_values)
        first = False
    for cell in monthly_metrics_worksheet[1]:
        cell.font = Font(name="Aptos", size=9, bold=True)
        cell.alignment = Alignment("left", "center")
    monthly_metrics_worksheet.freeze_panes = "A2"
    monthly_metrics_worksheet.auto_filter.ref = f"A1:{get_column_letter(monthly_metrics_worksheet.max_column)}{monthly_metrics_worksheet.max_row}"
    for col_letter, width in METRICS_HEADER_COL_WIDTHS.items():
      monthly_metrics_worksheet.column_dimensions[col_letter].width = width
    format_metrics_cells(monthly_metrics_worksheet)
    add_overall_summary_sheet(monthly_workbook, monthly_metrics_worksheet)
    weekly_sheet = add_weekly_summary_sheet(monthly_workbook)
    write_weekly_summary(monthly_metrics_worksheet, weekly_sheet)
    monthly_workbook.save(monthly_path)
    return monthly_path


# === input_processing.py ===

from __future__ import annotations
import os
from openpyxl import load_workbook, Workbook
from openpyxl.utils import get_column_letter
from openpyxl.styles import Font
from constants import INPUT_DATA_WORKSHEET_NAME, WORKSHEET_PREFIX

def add_input_data_worksheet_with_metadata(monthly_workbook: Workbook, metrics_workbook_paths: list[str]) -> None:
    consolidated_input_worksheet  = monthly_workbook.create_sheet(INPUT_DATA_WORKSHEET_NAME, 0)
    header_written = True
    for metrics_path in metrics_workbook_paths:
        metrics_workbook = load_workbook(metrics_path)
        input_sheet_name = next(name for name in metrics_workbook.sheetnames if name.startswith(WORKSHEET_PREFIX))
        input_worksheet = metrics_workbook[input_sheet_name]
        metadata_value = os.path.splitext(os.path.basename(metrics_path))[0]
        for row_index, row_values in enumerate(input_worksheet.iter_rows(values_only=True), start=1):
            if row_index == 1:
                if header_written:
                    consolidated_input_worksheet.append(["metadata"] + list(row_values))
                    header_written = False
                continue
            if not any((str(cell).strip() if cell is not None else "") for cell in row_values):
                continue
            consolidated_input_worksheet.append([metadata_value] + list(row_values))
    consolidated_input_worksheet.freeze_panes = "A2"
    consolidated_input_worksheet.auto_filter.ref = f"A1:{get_column_letter(consolidated_input_worksheet.max_column)}{consolidated_input_worksheet .max_row}"
    for col in range(1, consolidated_input_worksheet.max_column + 1):
        consolidated_input_worksheet.column_dimensions[get_column_letter(col)].width = 35
    for cell in consolidated_input_worksheet [1]:
        cell.font = Font(name="Aptos", size=9, bold=True)

# === main.py ===

from __future__ import annotations
from constants import ROOT_DIR, SPREADSHEET_PREFIX, DO_MONTHLY_CONSOLIDATION
from file_io import list_input_spreadsheets, build_metrics_workbook_from_input, create_monthly_workbook, qualifies_for_processing

def main() -> None:
    input_files = list_input_spreadsheets(ROOT_DIR)
    metrics_files: list[str] = []
    for index, input_path in enumerate(input_files, start=1):
        ok, _ = qualifies_for_processing(input_path)
        if not ok:
            print(f"{index}/{len(input_files)} Skipping {input_path}: no worksheet starting with {SPREADSHEET_PREFIX}")
            continue
        output_path = build_metrics_workbook_from_input(input_path)
        if output_path:
            metrics_files.append(output_path)
            print(f"{index}/{len(input_files)} Saved metrics and summaries to {output_path}")
    if DO_MONTHLY_CONSOLIDATION and metrics_files:
        monthly_path = create_monthly_workbook(ROOT_DIR, metrics_files, SPREADSHEET_PREFIX)
        print(f"Saved monthly consolidated metrics to {monthly_path}")

if __name__ == "__main__":
    main()


# === metrics_processing.py ===

from __future__ import annotations
from typing import Tuple
import re
import random
import requests
from openpyxl import Workbook
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.styles import Font, Alignment
from constants import (
    USE_HALLUCINATION_FLAGS,
    CODE_IS_BEING_TESTED,
    WER_POST_ENDPOINT,
    NUMBER_OF_SECTIONS,
    METRICS_WORKSHEET_NAME,
    METADATA_COL_NAME,
    SESSION_ID_COL_NAME,
    SECTION_COL_NAME,
    ENTIRE_COL_NAME,
    GT_SECTION_TEXT_COL_NAME,
    MODEL_SECTION_TEXT_COL_NAME,
    WER_COL_NAME,
    HALLUCINATION_COUNT_COL_NAME,
    GT_TOKS_COL_NAME,
    HALLUCINATION_PERCENT_COL_NAME,
    SESSION_ID_COL_NAME as SESSION_ID,
    RAW_TRANSCRIPT_COL_NAME as RAW_TRANSCRIPT,
    GROUND_TRUTH_COL_NAME as GROUND_TRUTH,
    HALLUCINATION_COL_NAME as HALLUCINATION,
)
from styling import THIN_BORDER, style_metrics_columns
from openpyxl.styles import PatternFill
from constants import CALL_LEVEL_BKGND_COLOR, SAMPLE_LEVEL_BKGND_COLOR

def get_column_index_map(worksheet: Worksheet) -> dict[str, int]:
    return {cell.value: idx for idx, cell in enumerate(worksheet[1], start=1)}

def preprocess_text(text: str) -> str:
    if not text:
        return ""
    lowered = str(text).lower()
    lowered = re.sub(r"[.,\-?…]", " ", lowered)
    lowered = re.sub(r"\{[^}]*\}", "", lowered)
    lowered = re.sub(r"[\[\]]", "", lowered)
    return re.sub(r"\s+", " ", lowered).strip()

def get_wer_from_api(endpoint: str, ground_truth: str, transcript: str) -> Tuple[float, int]:
    if CODE_IS_BEING_TESTED:
        # gt_len = len(ground_truth.split())
        # print(f"ground_truth: {ground_truth}, len: {gt_len}")
        return round(random.uniform(0, 100), 4), len(ground_truth.split())
    try:
        response = requests.post(endpoint, json={"groundTruth": ground_truth, "transcript": transcript}, verify=False, timeout=10)
        data = response.json()
        return round(float(data[0]), 4), int(data[1])
    except Exception:
        return float("nan"), None

def build_sessions_from_rows(worksheet: Worksheet) -> dict[str, list[tuple[str, str]]]:
    header_map = get_column_index_map(worksheet)
    session_id_index = header_map[SESSION_ID] - 1
    raw_transcript_index = header_map[RAW_TRANSCRIPT] - 1
    ground_truth_index = header_map[GROUND_TRUTH] - 1
    rows = [row for row in worksheet.iter_rows(min_row=2, values_only=True) if str(row[session_id_index] or "").strip()]
    sessions: dict[str, list[tuple[str, str]]] = {}
    for row in rows:
        session_id_value = str(row[session_id_index]).strip()
        sessions.setdefault(session_id_value, []).append((row[raw_transcript_index], row[ground_truth_index]))
    return sessions

def get_hallucination_counts(worksheet: Worksheet, session_id: str) -> list[int]:
    header_map = get_column_index_map(worksheet)
    session_id_index = header_map[SESSION_ID] - 1
    hallucination_index = header_map[HALLUCINATION] - 1
    counts: list[int] = []
    for row in worksheet.iter_rows(min_row=2, values_only=True):
        if len(row) <= max(session_id_index, hallucination_index):
            continue
        row_session_id = str(row[session_id_index] or "").strip()
        if row_session_id != session_id:
            continue
        hallucination = row[hallucination_index]
        if not hallucination:
            counts.append(0)
        elif USE_HALLUCINATION_FLAGS:
            counts.append(1)
        else:
            counts.append(len(str(hallucination).strip().split()))
    return counts

def compute_section_spans(total_items: int, section_count: int) -> list[tuple[int, int]]:
    if total_items == 0 or section_count <= 0:
        return []
    base_size = total_items // section_count
    remainder = total_items % section_count
    spans: list[tuple[int, int]] = []
    start = 0
    for i in range(1, section_count + 1):
        size = base_size + (1 if i <= remainder else 0)
        if size == 0:
            break
        end = start + size
        spans.append((start, end))
        start = end
    return spans

def join_texts_and_compute_wer(ground_truth_parts: list[str], transcript_parts: list[str]) -> tuple[str, str, float, int]:
    ground_truth_joined = " ".join(preprocess_text(x) for x in ground_truth_parts)
    transcript_joined = " ".join(preprocess_text(x) for x in transcript_parts)
    wer_value, ground_truth_token_count = get_wer_from_api(WER_POST_ENDPOINT, ground_truth_joined, transcript_joined)
    return ground_truth_joined, transcript_joined, wer_value, ground_truth_token_count

def add_metrics_sheet(workbook: Workbook) -> Worksheet:
    if METRICS_WORKSHEET_NAME in workbook.sheetnames:
        del workbook[METRICS_WORKSHEET_NAME]
    return workbook.create_sheet(METRICS_WORKSHEET_NAME)

def write_metrics_header(worksheet: Worksheet) -> None:
    headers = [
        METADATA_COL_NAME,
        SESSION_ID_COL_NAME,
        SECTION_COL_NAME,
        GT_SECTION_TEXT_COL_NAME,
        MODEL_SECTION_TEXT_COL_NAME,
        WER_COL_NAME,
        HALLUCINATION_COUNT_COL_NAME,
        GT_TOKS_COL_NAME,
        HALLUCINATION_PERCENT_COL_NAME,
    ]
    for column_index, title in enumerate(headers, start=1):
        cell = worksheet.cell(1, column_index, title)
        cell.font = Font(name="Aptos", size=9, bold=True)
        cell.alignment = Alignment("left", "center")
    worksheet.freeze_panes = "A2"

def write_metrics_row(
    worksheet: Worksheet,
    metadata_value: str,
    session_id_value: str,
    section_value,
    ground_truth_text: str,
    model_text: str,
    wer_value: float,
    hallucination_token_count: int,
    ground_truth_token_count: int,
    hallucination_percent: float,
    is_entire: bool = False
) -> int:
    row_index = worksheet.max_row + 1
    font = Font(name="Aptos", size=9)
    alignment = Alignment("left", "center")
    fill = PatternFill("solid", fgColor=CALL_LEVEL_BKGND_COLOR if is_entire else SAMPLE_LEVEL_BKGND_COLOR)
    values = (
        metadata_value,
        session_id_value,
        section_value,
        ground_truth_text,
        model_text,
        wer_value,
        hallucination_token_count,
        ground_truth_token_count,
        hallucination_percent,
    )
    for column_index, value in enumerate(values, start=1):
        cell = worksheet.cell(row_index, column_index, value)
        cell.font = font
        cell.alignment = alignment
        cell.fill = fill
        cell.border = THIN_BORDER
        header_value = worksheet.cell(1, column_index).value
        if header_value == WER_COL_NAME:
            cell.number_format = "0.00"
        if header_value == HALLUCINATION_PERCENT_COL_NAME:
            cell.number_format = "0.00"
    return row_index

def process_session(
    input_worksheet: Worksheet,
    metrics_worksheet: Worksheet,
    metadata_value: str,
    session_id: str,
    transcript_and_gt_pairs: list[tuple[str, str]]
) -> None:
    hallucination_counts = get_hallucination_counts(input_worksheet, session_id)
    ground_truth_full = [gt for _, gt in transcript_and_gt_pairs]
    transcript_full = [raw for raw, _ in transcript_and_gt_pairs]
    gt_joined, raw_joined, wer_full, gt_tokens_full = join_texts_and_compute_wer(ground_truth_full, transcript_full)
    hallucination_total = sum(hallucination_counts)
    hallucination_percent = (100 * hallucination_total / gt_tokens_full) if gt_tokens_full else None
    write_metrics_row(
        metrics_worksheet,
        metadata_value,
        session_id,
        ENTIRE_COL_NAME,
        gt_joined,
        raw_joined,
        wer_full,
        hallucination_total,
        gt_tokens_full,
        hallucination_percent,
        True
    )
    spans = compute_section_spans(len(transcript_and_gt_pairs), NUMBER_OF_SECTIONS)
    for section_number, (a, b) in enumerate(spans, start=1):
        block = transcript_and_gt_pairs[a:b]
        hallucination_block = hallucination_counts[a:b]
        gt_block = [gt for _, gt in block]
        raw_block = [raw for raw, _ in block]
        gt_join, raw_join, wer_join, gt_tok_join = join_texts_and_compute_wer(gt_block, raw_block)
        hallucination_sum = sum(hallucination_block)
        hallucination_pct = (100 * hallucination_sum / gt_tok_join) if gt_tok_join else None
        write_metrics_row(
            metrics_worksheet,
            metadata_value,
            session_id,
            section_number,
            gt_join,
            raw_join,
            wer_join,
            hallucination_sum,
            gt_tok_join,
            hallucination_pct
        )
    style_metrics_columns(metrics_worksheet)

def compute_and_write_session_metrics(input_worksheet: Worksheet, metrics_worksheet: Worksheet, metadata_value: str) -> None:
    sessions = build_sessions_from_rows(input_worksheet)
    if not sessions:
        return
    for session_id, transcript_and_gt_pairs in sessions.items():
        process_session(input_worksheet, metrics_worksheet, metadata_value, session_id, transcript_and_gt_pairs)

# === overall_summary.py ===

from __future__ import annotations
import re
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.styles import Font, Alignment, PatternFill
from constants import (
  CALL_SUMMARY_WORKSHEET_NAME,
  METADATA_COL_NAME,
  AVERAGE_WER_COL_NAME,
  SESSION_COUNT_COL_NAME,
  AVG_HALLUCINATION_PERCENT_COL_NAME,
  WER_COL_NAME,
  HALLUCINATION_PERCENT_COL_NAME,
  SECTION_COL_NAME,
  ENTIRE_COL_NAME,
  SPREADSHEET_PREFIX,
  CALL_LEVEL_GRANULARITY,
  CALL_LEVEL_BKGND_COLOR,
  SAMPLE_LEVEL_BKGND_COLOR,
  SUMMARY_COL_WIDTHS,
)
from styling import THIN_BORDER

def normalize_metadata(rows: list[list[str]], meta_index: int, prefix: str) -> str:
    metas = [r[meta_index] for r in rows if r[meta_index]]
    parts = [re.search(r"_(\d{4})(?:thru|-)(\d{4})_(\d{4})", m) for m in metas if m]
    earliest = min(p.group(1) for p in parts if p)
    latest = max(p.group(2) for p in parts if p)
    year = parts[0].group(3) if parts else "????"
    return f"{prefix}_{earliest}-{latest}_{year}"

def add_overall_summary_sheet(workbook, metrics_worksheet: Worksheet) -> None:
    if CALL_SUMMARY_WORKSHEET_NAME in workbook.sheetnames:
        del workbook[CALL_SUMMARY_WORKSHEET_NAME]
    summary_sheet = workbook.create_sheet(CALL_SUMMARY_WORKSHEET_NAME)
    headers = [METADATA_COL_NAME, AVERAGE_WER_COL_NAME, SESSION_COUNT_COL_NAME, AVG_HALLUCINATION_PERCENT_COL_NAME]
    for col, title in enumerate(headers, start=1):
        cell = summary_sheet.cell(1, col, title)
        cell.font = Font(name="Aptos", size=9, bold=True)
        cell.alignment = Alignment("left", "center")
    header_map = {c.value: idx for idx, c in enumerate(metrics_worksheet[1], start=1)}
    rows = list(metrics_worksheet.iter_rows(min_row=2, values_only=True))
    wer_index = header_map[WER_COL_NAME] - 1
    hallucination_percent_index = header_map[HALLUCINATION_PERCENT_COL_NAME] - 1
    section_index = header_map[SECTION_COL_NAME] - 1
    metadata_index = header_map[METADATA_COL_NAME] - 1
    if CALL_LEVEL_GRANULARITY:
        wer_values = [row[wer_index] for row in rows if row[section_index] == ENTIRE_COL_NAME and isinstance(row[wer_index], (int, float))]
        hallucination_values = [row[hallucination_percent_index] for row in rows if row[section_index] == ENTIRE_COL_NAME and isinstance(row[hallucination_percent_index], (int, float))]
    else:
        wer_values = [row[wer_index] for row in rows if row[section_index] != ENTIRE_COL_NAME and isinstance(row[wer_index], (int, float))]
        hallucination_values = [row[hallucination_percent_index] for row in rows if row[section_index] != ENTIRE_COL_NAME and isinstance(row[hallucination_percent_index], (int, float))]
    average_wer = sum(wer_values) / len(wer_values) if wer_values else 0.0
    average_hallucination = sum(hallucination_values) / len(hallucination_values) if hallucination_values else 0.0
    normalized_meta = normalize_metadata(rows, metadata_index, SPREADSHEET_PREFIX)
    session_count = sum(1 for row in rows if row[section_index] == ENTIRE_COL_NAME)
    values = [normalized_meta, average_wer, session_count, average_hallucination]

    for col, value in enumerate(values, start=1):
        cell = summary_sheet.cell(2, col, value)
        cell.font = Font(name="Aptos", size=9)
        cell.alignment = Alignment("left", "center")
        cell.fill = PatternFill("solid", fgColor=CALL_LEVEL_BKGND_COLOR if CALL_LEVEL_GRANULARITY else SAMPLE_LEVEL_BKGND_COLOR)
        cell.border = THIN_BORDER
        if col in (2, 4):
          cell.number_format = "0.00"

    for col_letter, width in SUMMARY_COL_WIDTHS.items():
        summary_sheet.column_dimensions[col_letter].width = width


# === styling.py ===

from __future__ import annotations
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from openpyxl.utils import get_column_letter
from constants import (
    CALL_LEVEL_BKGND_COLOR,
    SAMPLE_LEVEL_BKGND_COLOR,
    ENTIRE_COL_NAME,
    WER_COL_NAME,
    HALLUCINATION_PERCENT_COL_NAME,
    SOURCE_COL_WIDTHS,
    METRICS_HEADER_COL_WIDTHS,
)

THIN_SIDE = Side(border_style="thin", color="D3D3D3")
THIN_BORDER = Border(top=THIN_SIDE, bottom=THIN_SIDE, left=THIN_SIDE, right=THIN_SIDE)

def set_column_widths_by_letters(worksheet: Worksheet, letter_to_width: dict[str, float]) -> None:
    for letter, width in letter_to_width.items():
        worksheet.column_dimensions[letter].width = width

def style_copied_input_worksheet(worksheet: Worksheet) -> None:
    set_column_widths_by_letters(worksheet, SOURCE_COL_WIDTHS)
    worksheet.freeze_panes = "A2"
    worksheet.auto_filter.ref = f"A1:D{worksheet.max_row}"
    for cell in worksheet[1]:
        cell.font = Font(name="Aptos", size=9, bold=True)

def style_metrics_header(worksheet: Worksheet) -> None:
    for cell in worksheet[1]:
        cell.font = Font(name="Aptos", size=9, bold=True)
        cell.alignment = Alignment("left", "center")
    worksheet.freeze_panes = "A2"
    worksheet.auto_filter.ref = f"A1:{get_column_letter(worksheet.max_column)}{worksheet.max_row}"
    set_column_widths_by_letters(worksheet, METRICS_HEADER_COL_WIDTHS)

def style_metrics_columns(worksheet: Worksheet) -> None:
    for col_index, width in {1: 27, 2: 65, 3: 9, 4: 63, 5: 63, 6: 9, 7: 12, 8: 10, 9: 15}.items():
        worksheet.column_dimensions[get_column_letter(col_index)].width = width
    worksheet.auto_filter.ref = f"A1:I{worksheet.max_row}"

def format_metrics_cells(worksheet: Worksheet) -> None:
    header_map = {c.value: idx for idx, c in enumerate(worksheet[1], start=1)}
    wer_index = header_map[WER_COL_NAME] - 1
    hallucination_percent_index = header_map[HALLUCINATION_PERCENT_COL_NAME] - 1
    section_index = header_map["section"] - 1
    for row in worksheet.iter_rows(min_row=2):
        if row[wer_index].value is not None:
            row[wer_index].number_format = "0.00"
        if row[hallucination_percent_index].value is not None:
            row[hallucination_percent_index].number_format = "0.00000"
        background_color = CALL_LEVEL_BKGND_COLOR if row[section_index].value == ENTIRE_COL_NAME else SAMPLE_LEVEL_BKGND_COLOR
        for cell in row:
            cell.fill = PatternFill("solid", fgColor=background_color)
            cell.border = THIN_BORDER

def set_weekly_summary_column_widths(worksheet: Worksheet) -> None:
    widths = [20, 9, 12, 16]
    for col_index, width in enumerate(widths, start=1):
        worksheet.column_dimensions[get_column_letter(col_index)].width = width


# === weekly_summary.py ===

from __future__ import annotations
from collections import defaultdict
from openpyxl.worksheet.worksheet import Worksheet
from openpyxl.styles import Font, PatternFill
from constants import (
    METADATA_COL_NAME,
    AVERAGE_WER_COL_NAME,
    SESSION_COUNT_COL_NAME,
    AVG_HALLUCINATION_PERCENT_COL_NAME,
    ENTIRE_COL_NAME,
    WER_COL_NAME,
    HALLUCINATION_PERCENT_COL_NAME,
    WEEKLY_SUMMARY_WORKSHEET_NAME,
    SPREADSHEET_PREFIX,
    CALL_LEVEL_BKGND_COLOR,
)
from styling import set_weekly_summary_column_widths
from overall_summary import normalize_metadata

def add_weekly_summary_sheet(workbook) -> Worksheet:
    if WEEKLY_SUMMARY_WORKSHEET_NAME in workbook.sheetnames:
        del workbook[WEEKLY_SUMMARY_WORKSHEET_NAME]
    return workbook.create_sheet(WEEKLY_SUMMARY_WORKSHEET_NAME)

def write_weekly_summary(metrics_worksheet: Worksheet, summary_worksheet: Worksheet) -> None:
    write_weekly_summary_header(summary_worksheet)
    summaries = extract_metadata_groups(metrics_worksheet)
    write_weekly_summary_rows(summary_worksheet, summaries, start_row=3)
    write_weekly_summary_final_row(summary_worksheet, summaries)
    set_weekly_summary_column_widths(summary_worksheet)

def write_weekly_summary_header(summary_worksheet: Worksheet) -> None:
    titles = [METADATA_COL_NAME, AVERAGE_WER_COL_NAME, SESSION_COUNT_COL_NAME, AVG_HALLUCINATION_PERCENT_COL_NAME]
    for index, title in enumerate(titles, start=1):
        cell = summary_worksheet.cell(1, index, title)
        cell.font = Font(name="Aptos", size=9, bold=True)

def extract_metadata_groups(metrics_worksheet: Worksheet) -> dict[str, list[tuple[float, float]]]:
    header_map = {c.value: idx for idx, c in enumerate(metrics_worksheet[1], start=1)}
    metadata_index = header_map[METADATA_COL_NAME] - 1
    wer_index = header_map[WER_COL_NAME] - 1
    hallucination_percent_index = header_map[HALLUCINATION_PERCENT_COL_NAME] - 1
    section_index = header_map["section"] - 1
    groups = defaultdict(list)
    for row in metrics_worksheet.iter_rows(min_row=2, values_only=True):
        if row[section_index] == ENTIRE_COL_NAME:
            metadata_value = str(row[metadata_index])
            wer_value = row[wer_index]
            hallucination_value = row[hallucination_percent_index]
            if wer_value is not None:
                groups[metadata_value].append((wer_value, hallucination_value))
    return groups

def write_weekly_summary_rows(summary_worksheet: Worksheet, summaries: dict[str, list[tuple[float, float]]], start_row: int) -> None:
    for row_offset, (metadata_value, rows) in enumerate(summaries.items(), start=start_row):
        wer_values = [w for w, _ in rows]
        hallucination_values = [h for _, h in rows if h is not None]
        average_wer = round(sum(wer_values) / len(wer_values), 2) if wer_values else None
        average_hallucination = round(sum(hallucination_values) / len(hallucination_values), 5) if hallucination_values else None
        count = len(wer_values)
        summary_worksheet.cell(row_offset, 1, metadata_value)
        summary_worksheet.cell(row_offset, 2, average_wer)
        summary_worksheet.cell(row_offset, 3, count)
        summary_worksheet.cell(row_offset, 4, average_hallucination)
        for col in range(1, 5):
            summary_worksheet.cell(row_offset, col).font = Font(name="Aptos", size=9)

def write_weekly_summary_final_row(summary_worksheet: Worksheet, summaries: dict[str, list[tuple[float, float]]]) -> None:
    all_rows = []
    for metadata_value, rows in summaries.items():
        for row in rows:
            all_rows.append((metadata_value, *row))
    wer_values = [row[1] for row in all_rows]
    hallucination_values = [row[2] for row in all_rows if row[2] is not None]
    total_sessions = len(all_rows)
    average_wer = round(sum(wer_values) / len(wer_values), 2) if wer_values else None
    average_hallucination = round(sum(hallucination_values) / len(hallucination_values), 5) if hallucination_values else None
    metadata_rows_only = [[row[0] for row in all_rows]]
    normalized_metadata = normalize_metadata(metadata_rows_only, 0, SPREADSHEET_PREFIX)
    final_row_index = len(summaries) + 4
    summary_worksheet.cell(final_row_index, 1, normalized_metadata)
    summary_worksheet.cell(final_row_index, 2, average_wer)
    summary_worksheet.cell(final_row_index, 3, total_sessions)
    summary_worksheet.cell(final_row_index, 4, average_hallucination)
    for col in range(1, 5):
        cell = summary_worksheet.cell(final_row_index, col)
        cell.font = Font(name="Aptos", size=9)
        cell.fill = PatternFill("solid", fgColor=CALL_LEVEL_BKGND_COLOR)
        if col in (2, 4):
            cell.number_format = "0.00"