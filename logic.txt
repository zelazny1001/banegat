//=====================================================================

public static byte[] zeroPad(byte[] inputData, int paddingSize, boolean padLeft, boolean padRight) {
    byte zeroLevel = (byte) 0xFF;
    int originalLength = (inputData != null ? inputData.length : 0);
    int leftCount  = padLeft  ? paddingSize : 0;
    int rightCount = padRight ? paddingSize : 0;
    byte[] padded = new byte[leftCount + originalLength + rightCount];
    
    int destPos = 0;
    // left padding
    for (int i = 0; i < leftCount; i++) {
        padded[destPos++] = zeroLevel;
    }
    // copy original data
    if (inputData != null) {
        System.arraycopy(inputData, 0, padded, destPos, originalLength);
        destPos += originalLength;
    }
    // right padding
    for (int i = 0; i < rightCount; i++) {
        padded[destPos++] = zeroLevel;
    }
    
    return padded;
}

//=====================================================================

package analyzer;

public class SpikeInfo {
    private final int startIndex;
    private final int length;
    private final byte backgroundValue;

    public SpikeInfo(int startIndex, int length, byte backgroundValue) {
        this.startIndex = startIndex;
        this.length = length;
        this.backgroundValue = backgroundValue;
    }

    public int getStartIndex() {
        return startIndex;
    }

    public int getLength() {
        return length;
    }

    public byte getBackgroundValue() {
        return backgroundValue;
    }
}

//=======================================================================

package analyzer;

import java.util.ArrayList;
import java.util.List;

public class SpikeDetector {
    // background is: mu-law zero-level codes
    private static final byte BACKGROUND_LEVEL_LOW = (byte) 0xFF;   // -1
    private static final byte BACKGROUND_LEVEL_HIGH = (byte) 0x7F;  // 127

    public static boolean isBackground(byte value) {
        return value == BACKGROUND_LEVEL_LOW || value == BACKGROUND_LEVEL_HIGH;
    }

    public static List<SpikeInfo> detectSpikes(
            byte[] data,
            int maxSpikeWidth,
            int backgroundDuration
    ) {
        List<SpikeInfo> spikes = new ArrayList<>();
        int length = data.length;
        if (length < backgroundDuration * 2 + 1) {
            return spikes;
        }
        int index = backgroundDuration;
        while (index < length - backgroundDuration) {
            if (!isBackground(data[index])) {
                int end = index + 1;
                while (end < length - backgroundDuration
                        && end < index + maxSpikeWidth
                        && !isBackground(data[end])) {
                    end++;
                }
                int spikeLength = end - index;
                if (spikeLength <= maxSpikeWidth) {
                    boolean beforeOk = true;
                    for (int i = index - backgroundDuration; i < index; i++) {
                        if (!isBackground(data[i])) {
                            beforeOk = false;
                            break;
                        }
                    }
                    boolean afterOk = true;
                    for (int i = end; i < end + backgroundDuration; i++) {
                        if (!isBackground(data[i])) {
                            afterOk = false;
                            break;
                        }
                    }
                    if (beforeOk && afterOk) {
                        byte bgValue = data[index - 1];
                        spikes.add(new SpikeInfo(index, spikeLength, bgValue));
                        index = end;
                        continue;
                    }
                }
            }
            index++;
        }
        return spikes;
    }

    public static void removeSpikes(byte[] data, List<SpikeInfo> spikes) {
        for (SpikeInfo spike : spikes) {
            int start = spike.getStartIndex();
            int end = start + spike.getLength();
            byte backgroundBeforeSpike = spike.getBackgroundValue();
            for (int i = start; i < end; i++) {
                data[i] = backgroundBeforeSpike;
            }
        }
    }
}

//============================================================================

package analyzer;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;
import java.util.Arrays;

public class SpikeDetectorTest {
    private static final int MAX_SPIKE_WIDTH = 3;
    private static final int BACKGROUND_DURATION = 2;
    private static final byte LOW = (byte)0xFF;
    private static final byte HIGH = (byte)0x7F;

    @Test
    public void testNoSpikes_dataUnchanged() {
        byte[] data = new byte[] {LOW, LOW, HIGH, HIGH, LOW, HIGH, LOW};
        byte[] original = data.clone();
        List<SpikeInfo> spikes = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, BACKGROUND_DURATION);
        assertTrue(spikes.isEmpty());
        SpikeDetector.removeSpikes(data, spikes);
        assertArrayEquals(original, data);
    }

    @Test
    public void testSingleSpike_detectPosition() {
        byte[] data = new byte[] {LOW, LOW, LOW, 10, LOW, LOW, LOW};
        List<SpikeInfo> spikes = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, BACKGROUND_DURATION);
        assertEquals(1, spikes.size());
        SpikeInfo spike = spikes.get(0);
        assertEquals(3, spike.getStartIndex());
        assertEquals(1, spike.getLength());
        assertEquals(LOW, spike.getBackgroundValue());
    }

    @Test
    public void testSingleSpike_removed() {
        byte[] data = new byte[] {LOW, LOW, LOW, 10, LOW, LOW, LOW};
        List<SpikeInfo> spikes = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, BACKGROUND_DURATION);
        SpikeDetector.removeSpikes(data, spikes);
        assertEquals(LOW, data[3]);
        List<SpikeInfo> after = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, BACKGROUND_DURATION);
        assertTrue(after.isEmpty());
    }

    @Test
    public void testMultipleSpikes_variousCounts() {
        byte[] data0 = new byte[] {LOW, LOW, HIGH, HIGH, LOW};
        assertTrue(SpikeDetector.detectSpikes(data0, MAX_SPIKE_WIDTH, BACKGROUND_DURATION).isEmpty());

        byte[] data1 = new byte[] {LOW, LOW, 5, LOW, LOW};
        assertEquals(1, SpikeDetector.detectSpikes(data1, MAX_SPIKE_WIDTH, BACKGROUND_DURATION).size());

        byte[] data2 = new byte[] {LOW, LOW, 5, LOW, LOW, 6, LOW, LOW};
        assertEquals(2, SpikeDetector.detectSpikes(data2, MAX_SPIKE_WIDTH, BACKGROUND_DURATION).size());

        byte[] data3 = new byte[] {LOW, LOW, 5, 6, 7, LOW, LOW};
        assertEquals(1, SpikeDetector.detectSpikes(data3, MAX_SPIKE_WIDTH, BACKGROUND_DURATION).size());
    }

    @Test
    public void testBackgroundDuration15_noSpikes() {
        int duration = 15;
        byte[] data = new byte[duration * 2 + 1];
        Arrays.fill(data, LOW);
        List<SpikeInfo> spikes = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, duration);
        assertTrue(spikes.isEmpty());
    }

    @Test
    public void testBackgroundDuration15_oneSpike() {
        int duration = 15;
        byte[] data = new byte[duration * 2 + 1];
        Arrays.fill(data, LOW);
        int spikePos = duration;
        data[spikePos] = 42; // spike
        List<SpikeInfo> spikes = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, duration);
        assertEquals(1, spikes.size());
        SpikeInfo spike = spikes.get(0);
        assertEquals(spikePos, spike.getStartIndex());
        // removal
        SpikeDetector.removeSpikes(data, spikes);
        assertEquals(LOW, data[spikePos]);
        List<SpikeInfo> after = SpikeDetector.detectSpikes(data, MAX_SPIKE_WIDTH, duration);
        assertTrue(after.isEmpty());
    }
}