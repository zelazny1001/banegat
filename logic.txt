# dice_and_assemble_worksheets.py - Given a set of spreadsheets, each of which contains a target worksheet of the same name,
# aggregate all the rows of selected columns across all the spreadsheets and save to a new spreadsheet.

from __future__ import annotations
import os
import re
import csv
from typing import List, Tuple
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font
from openpyxl.worksheet.worksheet import Worksheet

INPUT_FOLDER =  "j:/projects/sheet-logic/"
OUTPUT_FOLDER = "j:/projects/sheet-logic/nlp-4-col/"
SUB_DIRS = ["nlp-4-col"]
FILENAME_PREFIX = "*" # only files with this prefix will be aggregated; if prefix is "*", then any .xlsx files will be aggregated
FILE_EXTENSION = ".xlsx"
TARGET_WORKSHEET = "raw data" # worksheet of columns in the workbook (spreadsheet)
COLUMNS_TO_BE_AGGREGATED = ["Metadata", "Metric", "Tester-1", "Tester-2", "Average"]
AGGREGATE_WORKSHEET_NAME = "consolidated-spreadsheet"
AGGREGATE_SPREADSHEET_NAME = AGGREGATE_WORKSHEET_NAME + FILE_EXTENSION
COLUMN_WIDTHS = [50, 26]
DO_PREPROCESS = False

def preprocess(text: str) -> str:
    if not text:
        return ""
    if DO_PREPROCESS:
        s = str(text).lower()
        s = re.sub(r"[.,\-?â€¦]", " ", s)
        s = re.sub(r"\{[^}]*\}", "", s)
        s = re.sub(r"[\[\]]", "", s)
        return re.sub(r"\s+", " ", s).strip()
    else:
        return text

def fetch_input_excel_data(
    root_dir: str,
    sub_dirs: List[str],
    prefix: str,
    extension: str,
    columns: List[str],
) -> List[Tuple[str, ...]]:
    rows: list[tuple[str, ...]] = []
    for sub in sub_dirs:
        path = os.path.join(root_dir, sub)
        for fname in os.listdir(path):
            ok_to_proceed = (fname.startswith(prefix) or prefix == '*') and fname.endswith(extension)
            if not ok_to_proceed:
                print(f'fname: {fname}: will not be processed - does not match file prefix criterion')
                continue
            workbook = load_workbook(os.path.join(path, fname), read_only=True, data_only=True)
            sheetnames = workbook.sheetnames
            if not TARGET_WORKSHEET in sheetnames:
                print(f'fname: {fname}: will not be processed - does not contain the Target Worksheet "{TARGET_WORKSHEET}"')
                continue
            print(f'processing: {fname} ...')
            worksheet = workbook[TARGET_WORKSHEET]
            header = list(next(worksheet.iter_rows(min_row=1, max_row=1, values_only=True)))
            try:
                idxs = [header.index(col) for col in columns]
            except ValueError:
                continue
            for row in worksheet.iter_rows(min_row=2, values_only=True):
                raw_cells = [row[i] or "" for i in idxs]
                processed = [preprocess(cell) for cell in raw_cells]
                if any(processed):
                    rows.append(tuple(processed))
    return rows

def write_aggregate_rows_to_worksheet(
    ws: Worksheet,
    columns: List[str],
    rows: List[Tuple[str, ...]],
) -> None:
    header_font = Font(name="Arial", size=10, bold=True)
    cell_font = Font(name="Arial", size=10)
    ws.append(["index", *columns, "match"])
    for idx, row in enumerate(rows, start=1):
        current_values = []
        for col_i, v in enumerate(row):
            if col_i >= len(row) - 2 and isinstance(v, str):
                current_values.append(v.upper() if v is not None else '')
            else:
                current_values.append(v if v is not None else '')

        if len(current_values) >= 2:
            match_flag = str(current_values[-2]) == str(current_values[-1])
        else:
            match_flag = False

        ws.append([idx] + current_values + [match_flag])

        total_cols = len(columns) + 2
    for row_cells in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=1, max_col=total_cols):
        for cell in row_cells:
            cell.font = header_font if cell.row == 1 else cell_font
    ws.freeze_panes = "A2"
    last_col = ws.cell(row=1, column=total_cols).column_letter
    ws.auto_filter.ref = f"A1:{last_col}{ws.max_row}"

def save_aggregate_rows_to_spreadsheet(
    root_dir: str,
    filename: str,
    sheet_name: str,
    columns: List[str],
    rows: List[Tuple[str, ...]],
) -> None:
    wb = Workbook()
    ws = wb.active
    ws.title = sheet_name
    write_aggregate_rows_to_worksheet(ws, columns, rows)
    wb.save(os.path.join(root_dir, filename))

def main() -> None:
    rows = fetch_input_excel_data(
        INPUT_FOLDER,
        SUB_DIRS,
        FILENAME_PREFIX,
        FILE_EXTENSION,
        COLUMNS_TO_BE_AGGREGATED,
    )
    if rows:
        save_aggregate_rows_to_spreadsheet(
            OUTPUT_FOLDER,
            AGGREGATE_SPREADSHEET_NAME,
            AGGREGATE_WORKSHEET_NAME,
            COLUMNS_TO_BE_AGGREGATED,
            rows,
        )

if __name__ == "__main__":
    main()