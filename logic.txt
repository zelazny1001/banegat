# interleave_agent_and_customer_calls.py

import re
from collections import defaultdict
from openpyxl import load_workbook
from openpyxl.styles import Font, numbers
from openpyxl.utils import get_column_letter

SPREADSHEET_PATH     = "j:/projects/sheet-logic/interleave-test3.xlsx"
ANALYSIS_WORKSHEET   = "analysis"
OUTPUT_WORKSHEET     = "interleaved"

AGENT_LABEL             = "Agent"
CUSTOMER_LABEL          = "Customer"
AGENT_SUFFIX_PATTERN    = r"_Agent_(\d+)[_-](\d+)"
CUSTOMER_SUFFIX_PATTERN = r"_Cust_(\d+)[_-](\d+)"

FILENAME_COLUMN        = "filename"
CONDITIONS_COLUMN      = "conditions"
SEQNUM_COLUMN          = "seqNum"
LOC_COLUMN             = "loc"
DUR_COLUMN             = "dur"
START_COLUMN           = "start"
END_COLUMN             = "end"
TRANSCRIPT_COLUMN      = "transcript"

CALL_COLUMN            = "call"
SPEAKER_COLUMN         = "speaker"
CALL_TRANSCRIPT_COLUMN = "call_transcript"

CALL_COLUMN_WIDTH    = 12
SPEAKER_COLUMN_WIDTH = 12

def format_numeric_columns(worksheet, idx_map):
    for col_name, (fmt, caster) in [
        (SEQNUM_COLUMN, (numbers.FORMAT_NUMBER, lambda x: int(float(x)))),
        (DUR_COLUMN,    ("0.000",             lambda x: float(x))),
        (START_COLUMN,  (numbers.FORMAT_NUMBER, lambda x: int(float(x)))),
        (END_COLUMN,    (numbers.FORMAT_NUMBER, lambda x: int(float(x))))
    ]:
        if col_name in idx_map:
            col = idx_map[col_name]
            for cell in worksheet.iter_cols(min_col=col, max_col=col, min_row=2, values_only=False):
                for c in cell:
                    if c.value is not None:
                        try:
                            c.value = caster(c.value)
                            c.number_format = fmt
                        except (ValueError, TypeError):
                            pass

def call_id_from_filename_suffix(filename: str) -> str:
    if not filename:
        return ""
    for pattern in (AGENT_SUFFIX_PATTERN, CUSTOMER_SUFFIX_PATTERN):
        m = re.search(pattern, str(filename))
        if m:
            return f"call_{m.group(1)}_{m.group(2)}"
    return ""

def get_speaker(filename: str) -> str:
    if not filename:
        return ""
    filename = str(filename)
    if "_Agent_" in filename:
        return AGENT_LABEL
    if "_Cust_" in filename:
        return CUSTOMER_LABEL
    return ""

def load_worksheet(path: str, worksheet: str):
    wb = load_workbook(path)
    if worksheet in wb.sheetnames:
        return wb, wb[worksheet]
    else:
        return wb, wb.create_sheet(worksheet)

def map_col_names_to_positions(worksheet) -> dict:
    headers = {}
    for idx, cell in enumerate(worksheet[1], start=1): # all cols in row 1 of the worksheet (the header)
        if isinstance(cell.value, str):
            headers[cell.value.strip()] = idx
    return headers

def read_records(worksheet, idx_map) -> list:
    records = []
    for row in range(2, worksheet.max_row + 1):
        filename = worksheet.cell(row=row, column=idx_map[FILENAME_COLUMN]).value
        start = worksheet.cell(row=row, column=idx_map[START_COLUMN]).value
        transcript = worksheet.cell(row=row, column=idx_map[TRANSCRIPT_COLUMN]).value
        if start is None or transcript is None:
            continue
        try:
            start_time = int(float(start))
        except (ValueError, TypeError):
            continue
        call_id = call_id_from_filename_suffix(filename)
        speaker = get_speaker(filename)
        if not call_id or not speaker:
            continue
        records.append({
            "row": row,
            "call": call_id,
            "speaker": speaker,
            "start": start_time,
            "transcript": transcript,
            "filename": worksheet.cell(row=row, column=idx_map[FILENAME_COLUMN]).value,
            "conditions": worksheet.cell(row=row, column=idx_map[CONDITIONS_COLUMN]).value,
            "seqNum": worksheet.cell(row=row, column=idx_map[SEQNUM_COLUMN]).value,
            "loc": worksheet.cell(row=row, column=idx_map[LOC_COLUMN]).value,
            "dur": worksheet.cell(row=row, column=idx_map[DUR_COLUMN]).value,
            "end": worksheet.cell(row=row, column=idx_map[END_COLUMN]).value
        })
    return records

def group_and_sort_records(records):
    call_groups = defaultdict(list)
    for rec in records:
        call_groups[rec[CALL_COLUMN]].append(rec)
    sorted_records = []
    for call_id, recs in call_groups.items():
        recs.sort(key=lambda r: (r[START_COLUMN], 1 if r[SPEAKER_COLUMN]==AGENT_LABEL else 0))
        sorted_records.extend(recs)
    return sorted_records

def create_output_worksheet(wb, src_ws, sorted_records, idx_map):
    if OUTPUT_WORKSHEET in wb.sheetnames:
        out_ws = wb[OUTPUT_WORKSHEET]
        out_ws.delete_rows(1, out_ws.max_row)
    else:
        out_ws = wb.create_sheet(OUTPUT_WORKSHEET)
    for name, col in idx_map.items():
        out_ws.cell(row=1, column=col, value=name)
    first_free = max(idx_map.values()) + 1
    call_col = first_free
    speaker_col = first_free + 1
    ct_col = first_free + 2
    out_ws.cell(row=1, column=call_col,    value=CALL_COLUMN)
    out_ws.cell(row=1, column=speaker_col, value=SPEAKER_COLUMN)
    out_ws.cell(row=1, column=ct_col,      value=CALL_TRANSCRIPT_COLUMN)
    return out_ws, call_col, speaker_col, ct_col

def apply_styling(out_ws, src_ws, idx_map, call_col, speaker_col, ct_col):
    header_font = Font(name="Aptos", size=9, bold=True)
    data_font = Font(name="Aptos", size=9)
    # copy widths for existing columns
    for name, col in idx_map.items():
        letter = get_column_letter(col)
        out_ws.column_dimensions[letter].width = src_ws.column_dimensions[letter].width
    out_ws.column_dimensions[get_column_letter(call_col)].width    = CALL_COLUMN_WIDTH
    out_ws.column_dimensions[get_column_letter(speaker_col)].width = SPEAKER_COLUMN_WIDTH
    # call_transcript width matches original transcript
    tr_w = src_ws.column_dimensions[get_column_letter(idx_map[TRANSCRIPT_COLUMN])].width
    out_ws.column_dimensions[get_column_letter(ct_col)].width = tr_w

    # apply fonts & freeze header row
    last_col = max(ct_col, max(idx_map.values()))
    for col in range(1, last_col + 1):
        out_ws.cell(row=1, column=col).font = header_font
        for r in range(2, out_ws.max_row + 1):
            out_ws.cell(row=r, column=col).font = data_font

    out_ws.freeze_panes = "A2"
    out_ws.auto_filter.ref = f"A1:{get_column_letter(last_col)}{out_ws.max_row}"

def interleave_calls():
    wb, src_ws = load_worksheet(SPREADSHEET_PATH, ANALYSIS_WORKSHEET)
    idx_map = map_col_names_to_positions(src_ws)
    format_numeric_columns(src_ws, idx_map)
    records = read_records(src_ws, idx_map)
    if not records:
        print("no valid records found")
        return
    sorted_records = group_and_sort_records(records)
    out_ws, call_col, speaker_col, ct_col = create_output_worksheet(
        wb, src_ws, sorted_records, idx_map
    )
    for i, rec in enumerate(sorted_records, start=2):
        out_ws.cell(row=i, column=idx_map[FILENAME_COLUMN],   value=rec['filename'])
        out_ws.cell(row=i, column=idx_map[CONDITIONS_COLUMN], value=rec['conditions'])
        out_ws.cell(row=i, column=idx_map[SEQNUM_COLUMN],     value=rec['seqNum'])
        out_ws.cell(row=i, column=idx_map[LOC_COLUMN],        value=rec['loc'])
        out_ws.cell(row=i, column=idx_map[DUR_COLUMN],        value=rec['dur'])
        out_ws.cell(row=i, column=idx_map[START_COLUMN],      value=rec['start'])
        out_ws.cell(row=i, column=idx_map[END_COLUMN],        value=rec['end'])
        out_ws.cell(row=i, column=idx_map[TRANSCRIPT_COLUMN], value=rec['transcript'])
        out_ws.cell(row=i, column=call_col,    value=rec['call'])
        out_ws.cell(row=i, column=speaker_col, value=rec['speaker'])
        out_ws.cell(row=i, column=ct_col,      value=rec['transcript'])
    apply_styling(out_ws, src_ws, idx_map, call_col, speaker_col, ct_col)
    wb.save(SPREADSHEET_PATH)

if __name__ == "__main__":
    interleave_calls()