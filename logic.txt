# wer_for_4_column_data.py

from __future__ import annotations
import os
import re
import httpx
from wer_nltk_local_compute import compute
from pathlib import Path
from openpyxl import load_workbook, Workbook
from openpyxl.styles import Font
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.worksheet import Worksheet
from concurrent.futures import ThreadPoolExecutor, as_completed

from nltk_jiwer_utils import (
    get_jiwer_result,
    get_nltk_result,
    get_wer_from_json
)

SPREADSHEET_DIR = Path("j:/projects/sheet-logic/test-sheets/")
SPREADSHEET_NAME = "test_4_col.xlsx"
TARGET_WORKSHEET = "base-vs-engine"
TRANSCRIPTION_DIR = Path("j:/tmp/vad/synthetics/engine-and-base-version-transcriptions/")
GT_DIR = Path("j:/projects/sheet-logic/ground-truths/")

USE_LOCAL_SERVER_WER = True # if False, then WER_ENDPOINT will be used
WER_ENDPOINT = "http://api_for_wer:2517/wer"
PARALLELIZE_WER = False  # if True, then WER_ENDPOINT will be triggered parallelized

ID_PREFIX = "synthetic_"
GT_PREFIX = "ground_truth_"
BASE_SUFFIX = "_Combined_base.txt"
ENGINE_SUFFIX = "_Combined_engine.txt"
COLUMN_HEADERS = ["ID", "GT", "distil-large-v2-model", "distil-large-v2-engine-int8", "model-WER", "engine-WER"]
COLUMN_WIDTHS = [15, 45, 45, 45, 12, 12]

def extract_ids(transcription_dir: Path) -> list[str]:
    filenames = [f.name for f in transcription_dir.glob("*.txt")]
    pattern = re.compile(r"Synthetic_(Call_\d+_\d+)_Combined_")
    ids = sorted({(ID_PREFIX + m.group(1).lower()) for f in filenames if (m := pattern.match(f))})
    return ids

def read_file(filepath: Path) -> str:
    return filepath.read_text(encoding="utf-8").strip()

def get_gt_text(call_id: str) -> str | None:
    filename = GT_PREFIX + call_id[len(ID_PREFIX):] + ".txt"
    path = GT_DIR / filename
    return read_file(path) if path.exists() else None

def get_base_transcription(call_id: str) -> str:
    filename = "Synthetic_" + call_id[len(ID_PREFIX):] + BASE_SUFFIX
    return read_file(TRANSCRIPTION_DIR / filename)

def get_engine_transcription(call_id: str) -> str:
    filename = "Synthetic_" + call_id[len(ID_PREFIX):] + ENGINE_SUFFIX
    return read_file(TRANSCRIPTION_DIR / filename)

def normalize_whitespace(text: str) -> str:
    return re.sub(r"\s+", " ", text).strip()

def calculate_wer(ground_truth: str, transcript: str) -> str:
    ground_truth = normalize_whitespace(ground_truth)
    transcript = normalize_whitespace(transcript)
    if USE_LOCAL_SERVER_WER:
       #local_server_wer = compute(ground_truth, transcript)
       jiwer_result_ = get_jiwer_result(ground_truth, transcript)
       jiwer_wer = get_wer_from_json(jiwer_result_)
       return f"{jiwer_wer:.2f}"
    else:
        resp = httpx.post(WER_ENDPOINT, json={"groundTruth": ground_truth, "transcript": transcript}, timeout=5.0)
        text = resp.text.strip()
        try:
            value = float(text)
            return f"{value:.2f}"
        except ValueError:
            return "WER API Error"

def calculate_wer_batch(pairs: list[tuple[int, str, str]]) -> dict[int, tuple[str, str]]:
    def worker(index: int, gt: str, model: str, engine: str) -> tuple[int, tuple[str, str]]:
        try:
            wer_model = calculate_wer(gt, model)
        except Exception:
            wer_model = "WER API Error"
        try:
            wer_engine = calculate_wer(gt, engine)
        except Exception:
            wer_engine = "WER API Error"
        return index, (wer_model, wer_engine)

    results = {}
    with ThreadPoolExecutor(max_workers=6) as executor:
        futures = {executor.submit(worker, i, gt, model, engine): i for i, gt, model, engine in pairs}
        for future in as_completed(futures):
            i, wer_values = future.result()
            results[i] = wer_values
    return results

def format_worksheet(ws: Worksheet):
    font = Font(name="Aptos", size=9)
    header_font = Font(name="Aptos", size=9, bold=True)
    for row in ws.iter_rows():
        for cell in row:
            cell.font = font
    for cell in ws[1]:
        cell.font = header_font
    ws.auto_filter.ref = ws.dimensions
    ws.freeze_panes = "A2"
    for i, width in enumerate(COLUMN_WIDTHS, 1):
        ws.column_dimensions[get_column_letter(i)].width = width

def write_data(ws: Worksheet, rows: list[list[str]]):
    ws.delete_rows(1, ws.max_row)
    ws.append(COLUMN_HEADERS)
    for i, row in enumerate(rows, 2):
        for j, value in enumerate(row, 1):
            ws.cell(i, j).value = value if value not in (None, "") else " "

def prepare_workbook() -> tuple[Workbook, Worksheet]:
    path = SPREADSHEET_DIR / SPREADSHEET_NAME
    if path.exists():
        wb = load_workbook(path)
        if TARGET_WORKSHEET in wb.sheetnames:
            ws = wb[TARGET_WORKSHEET]
        else:
            ws = wb.create_sheet(TARGET_WORKSHEET)
    else:
        wb = Workbook()
        default_sheet = wb.active
        wb.remove(default_sheet)
        ws = wb.create_sheet(TARGET_WORKSHEET)
    return wb, ws

def main():
    wb, ws = prepare_workbook()
    ids = extract_ids(TRANSCRIPTION_DIR)
    data = []
    total = len(ids)

    if PARALLELIZE_WER:
        wer_inputs = []

    for idx, call_id in enumerate(ids, 1):
        print(f"[{idx}/{total}] Processing {call_id}...")
        model_raw = get_base_transcription(call_id)
        engine_raw = get_engine_transcription(call_id)
        gt_raw = get_gt_text(call_id)

        model = normalize_whitespace(model_raw)
        engine = normalize_whitespace(engine_raw)

        if gt_raw is None:
            row = [call_id, "GT missing", model, engine, " ", " "]
        else:
            gt = normalize_whitespace(gt_raw)
            if USE_LOCAL_SERVER_WER:
                wer_model = calculate_wer(gt, model)
                wer_engine = calculate_wer(gt, engine)
                row = [call_id, gt, model, engine, wer_model, wer_engine]
            else:
                if PARALLELIZE_WER:
                    wer_inputs.append((idx - 1, gt, model, engine))
                    row = [call_id, gt, model, engine, None, None]
                else:
                    wer_model = calculate_wer(gt, model)
                    wer_engine = calculate_wer(gt, engine)
                    row = [call_id, gt, model, engine, wer_model, wer_engine]
        data.append(row)

    if PARALLELIZE_WER:
        wer_results = calculate_wer_batch(wer_inputs)
        for i, (wer_model, wer_engine) in wer_results.items():
            data[i][4] = wer_model
            data[i][5] = wer_engine

    write_data(ws, data)
    format_worksheet(ws)
    wb.save(SPREADSHEET_DIR / SPREADSHEET_NAME)

if __name__ == "__main__":
    main()